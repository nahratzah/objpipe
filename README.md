# objpipe

Objpipe is a library for iterating over collections, performing transformations,
and doing all that in a type agnostic manner.

## Requirements

C++17, although you'll probably get by with anything higher than C++14 (clang-4.0.0 with -std=c++1z works fine for me).

## Usage

An objpipe has three components:
1. A source of data.
2. A series of transformations on the data.
3. Accessing the data, for example via iteration, reduction, or pushing it onward.

Objpipe allows interface boundaries between each of those.

### Example: simple transformation

This example computes the squares of 1, 2, and 3.

    #include <objpipe/of.h>

    objpipe::of(1, 2, 3) // Create a source with three numbers.
        .transform([](int x) { return x * x; }) // Compute squares.
        .to_vector(); // returns std::vector<int>({ 1, 4, 9 }).

### Example: traversing interface boundaries

This example shows how the source can be abstracted away.

The ``objpipe::reader<T>`` allows us to abstract away a specific implementation
behind its interface.
Without conversion to ``objpipe::reader<T>``, the entire template of operations
would be visible.

    #include <vector>
    #include <cstdint>
    #include <objpipe/reader.h>
    #include <objpipe/array.h>
    #include <objpipe/callback.h>

    class MyIntf {
     public:
      virtual auto makeData() -> objpipe::reader<int> = 0;
    };

    class MyVectorImpl
    : public MyIntf
    {
     public:
      virtual auto makeData() -> objpipe::reader<int> override {
        return objpipe::new_array(data.begin(), data.end());
      }

     private:
      std::vector<int> data;
    };

    class MyCallbackImpl
    : public MyIntf {
     public:
      virtual auto makeData() -> objpipe::reader<int> override {
        return objpipe::new_callback<int>(
            [](auto& cb) {
              for (int i = 0; i < 42; ++i)
                cb(i);
            });
      }
    };

    std::uintmax_t countEvenNumbers(MyIntf& src) {
      return src.makeData()
          .filter([](int x) { return x % 2 == 0; })
          .count();
    }

### Example: map reduce

Various ways of computing the maximum value.

    #include <future>
    #include <optional>
    #include <objpipe/of.h>
    #include <objpipe/push_policies.h>

    // Compute immediately.
    std::optional<int> max = objpipe::of(3, 1, 2)
        .max();

    // Use asynchronous reduction.
    std::future<std::optional<int>> max_future = objpipe::of(3, 1, 2)
        .async()
        .max();

    // Use parallel reduction.
    std::future<std::optional<int>> max_future = objpipe::of(3, 1, 2)
        .async(objpipe::multithread_push())
        .max();

Another map reduce, that collects all elements into a set.

    #include <set>
    #include <utility>

    // Generic reduction.
    std::future<std::shared_ptr<std::set<int>>> int_set = objpipe::of(3, 1, 2)
        .async(objpipe::multithread_unordered_push())
        .reduce(
            []() -> { // Factory for initial state of reducer.
              return std::set<int>();
            },
            [](std::set<int>& state, int&& element) { // Value acceptor functor.
              state.insert(std::move(element));
            },
            [](std::set<int>& dst, std::set<int>&& to_add) { // Merge operation across states.
              state.merge(std::move(to_add));
            },
            [](std::set<int>&& state) { // Extract result from reduction.
              return std::make_shared<std::set<int>>(std::move(state));
            });

## Linking

This is a header-only library.

To use it, you can simple supply ``-I/path/to/monsoon-cache/include`` to the
compiler.
The callback requires that boost/context be linked in and
that boost/coroutines2 is on the include path.

If you're using CMake, you can instead import the library using (for instance)
a git submodule:

    add_subdirectory(path/to/objpipe)
    target_link_libraries(my_target objpipe)

If monsoon-cache is properly installed, the following should work:

    find_package(objpipe 0.0 REQUIRED)
    target_link_libraries(my_target objpipe)

(objpipe is an interface library, so it does not have an actual library,
but does contain options to link correctly (thread-safe) and get the correct
includes via the target.)
In both cases, the include directories are set correctly.

## Additional Documentation

Documentation can be generated by the ``objpipe-doc`` target.

Or alternatively, can be [browsed online](https://www.stack.nl/~ariane/objpipe/).
